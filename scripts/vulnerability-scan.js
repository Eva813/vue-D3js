#!/usr/bin/env node
import { execSync } from 'node:child_process'
import { writeFileSync } from 'node:fs'
import path from 'node:path'
import process from 'node:process'
const { console } = globalThis

// Enhanced vulnerability summarizer for the Copilot workflow
// - configurable minimum severity via env MIN_SEVERITY (critical|high|medium|low)
// - configurable max results via env MAX_RESULTS
// - outputs aggregated `packageSummary` and `severityCounts`

const ENV_MIN = (process.env.MIN_SEVERITY || 'high').toLowerCase()
const MAX_RESULTS = Number(process.env.MAX_RESULTS || 50)

const severityRank = {
  unknown: 0,
  low: 1,
  medium: 2,
  high: 3,
  critical: 4
}

const runAudit = () => {
  try {
    return execSync('pnpm audit --json', {
      stdio: ['ignore', 'pipe', 'pipe']
    }).toString()
  } catch (error) {
    if (error && error.stdout) return error.stdout.toString()
    console.error('[copilot] pnpm audit failed:', error?.message || error)
    return ''
  }
}

const getSeverity = (item) => {
  if (!item) return 'unknown'
  if (item.severity) return String(item.severity).toLowerCase()
  // fallback checks
  if (item.advisory && item.advisory.severity) return String(item.advisory.severity).toLowerCase()
  if (item.via && Array.isArray(item.via)) {
    const viaObj = item.via.find((v) => v && typeof v === 'object' && v.severity)
    if (viaObj) return String(viaObj.severity).toLowerCase()
  }
  return 'unknown'
}

const normalizeFinding = (raw) => {
  const name = raw?.name || raw?.module_name || raw?.id || 'unknown'
  const severity = getSeverity(raw)
  const url = raw?.url || raw?.advisoryUrl || raw?.npm_advisory_url || (raw?.advisory && raw.advisory.url) || ''
  const version = raw?.version || raw?.installed || raw?.installedVersion || null
  const range = raw?.range || raw?.vulnerable_versions || raw?.recommendation || null
  const cvss = raw?.cvssScore || raw?.cvss || (raw?.advisory && raw.advisory.cvss) || null
  const paths = raw?.findings?.flatMap((f) => f.paths || []) || raw?.paths || []

  return { name, severity, url, version, range, cvss, paths }
}

const parseReport = (report) => {
  const results = []

  // vulnerabilities (npm v7+ structure)
  if (report?.vulnerabilities && typeof report.vulnerabilities === 'object') {
    Object.values(report.vulnerabilities).forEach((item) => {
      const sev = getSeverity(item)
      if (severityRank[sev] >= severityRank[ENV_MIN]) results.push(normalizeFinding(item))
    })
  }

  // advisories (older formats)
  if (report?.advisories && typeof report.advisories === 'object') {
    Object.values(report.advisories).forEach((item) => {
      const sev = getSeverity(item)
      if (severityRank[sev] >= severityRank[ENV_MIN]) results.push(normalizeFinding(item))
    })
  }

  // flattened vulnerabilities array
  if (Array.isArray(report?.vulnerabilities)) {
    report.vulnerabilities.forEach((item) => {
      const sev = getSeverity(item)
      if (severityRank[sev] >= severityRank[ENV_MIN]) results.push(normalizeFinding(item))
    })
  }

  return results
}

const rawOutput = runAudit()
if (!rawOutput) {
  console.warn('[copilot] No pnpm audit JSON produced. Skipping dependency audit.')
  process.exit(0)
}

let parsed
try {
  parsed = JSON.parse(rawOutput)
} catch (err) {
  console.error('[copilot] Failed to parse pnpm audit output:', err.message)
  process.exit(0)
}

const findings = parseReport(parsed)

// Aggregate summary
const severityCounts = findings.reduce((acc, f) => {
  const s = f.severity || 'unknown'
  acc[s] = (acc[s] || 0) + 1
  return acc
}, {})

const packageSummary = {}
for (const f of findings) {
  const key = f.name || 'unknown'
  if (!packageSummary[key]) {
    packageSummary[key] = {
      name: key,
      highestSeverity: f.severity,
      count: 0,
      versions: new Set(),
      urls: new Set(),
      paths: new Set(),
      cvss: f.cvss || null
    }
  }
  const p = packageSummary[key]
  p.count += 1
  if (severityRank[f.severity] > severityRank[p.highestSeverity]) p.highestSeverity = f.severity
  if (f.version) p.versions.add(f.version)
  if (f.url) p.urls.add(f.url)
  if (Array.isArray(f.paths) && f.paths.length > 0) {
    f.paths.forEach((pp) => p.paths.add(pp))
  }
  if (!p.cvss && f.cvss) p.cvss = f.cvss
}

const packageSummaryArray = Object.values(packageSummary).map((p) => ({
  name: p.name,
  highestSeverity: p.highestSeverity,
  count: p.count,
  versions: Array.from(p.versions),
  urls: Array.from(p.urls),
  paths: Array.from(p.paths),
  cvss: p.cvss
}))

const output = {
  generatedAt: new Date().toISOString(),
  minSeverity: ENV_MIN,
  totals: parsed?.metadata?.vulnerabilities || parsed?.vulnerabilitiesSummary || {},
  severityCounts,
  findings: findings.slice(0, MAX_RESULTS),
  moreFindings: Math.max(0, findings.length - MAX_RESULTS),
  packageSummary: packageSummaryArray
}

const outputPath = path.resolve('.github', 'copilot-audit-report.json')
writeFileSync(outputPath, `${JSON.stringify(output, null, 2)}\n`, 'utf8')

if (findings.length > 0) {
  console.log(`⚠️ Found ${findings.length} dependency issues (minSeverity=${ENV_MIN}). Showing up to ${MAX_RESULTS}:`)
  packageSummaryArray.slice(0, 10).forEach((p) => {
    console.log(` - ${p.name}: ${p.highestSeverity} (${p.count}) versions=${p.versions.join(', ')}`)
  })
  if (packageSummaryArray.length > 10) console.log(`   ...and ${packageSummaryArray.length - 10} more packages.`)
} else {
  console.log('✅ No dependency findings at or above configured severity.')
}
